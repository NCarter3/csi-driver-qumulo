package qumulo

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"testing"
)

type Message struct {
	Uri              string
	StatusCode       int
	BodyIn			 string
	BodyOut          string
}

func assertMessagesConsumed(t *testing.T, messages []Message) {
	if len(messages) != 0 {
		t.Fatalf("not all messages used by test: %v", messages)
	}
}

func assertNoError(t *testing.T, err error) {
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func assertErrorMatchesString(t *testing.T, err error, needle string) {
	if err == nil {
		t.Fatal("unexpected nil error")
	}
	if !strings.Contains(err.Error(), needle) {
		t.Fatalf("error does not match %q: %q", needle, err.Error())
	}
}

type FakeTransport struct {
	test     *testing.T
	host     string
	port     int
	messages *[]Message
}

func (self *FakeTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	message := (*self.messages)[0]
	*self.messages = (*self.messages)[1:]

	expectedUrl := fmt.Sprintf("https://%s:%d%s", self.host, self.port, message.Uri)
	if req.URL.String() != expectedUrl {
		self.test.Fatalf("unexpected url %v != %s", req.URL, expectedUrl)
	}

	if req.Body != nil {
		body, err := ioutil.ReadAll(req.Body)
		req.Body.Close()
		if err != nil {
			self.test.Fatalf("assert %v", err)
		}
		if string(body) != message.BodyIn {
			self.test.Fatalf("unexpected body %v != %s", string(body), message.BodyIn)
		}
	}


	return &http.Response {
		StatusCode: message.StatusCode,
		Body:       ioutil.NopCloser(bytes.NewBufferString(message.BodyOut)),
		Header:     make(http.Header),
	}, nil
}

func newTestClient(t *testing.T, host string, port int, messages *[]Message) *http.Client {
	return &http.Client {
		Transport: &FakeTransport{t, host, port, messages},
	}
}

const (
	testHost = "1.2.3.4"
	testPort = 44
)

/*  _            _
 * | |_ ___  ___| |_ ___
 * | __/ _ \/ __| __/ __|
 * | ||  __/\__ \ |_\__ \
 *  \__\___||___/\__|___/
 *  FIGLET: tests
 */

func TestRestAutoLoginSucces(t *testing.T) {
	messages := []Message {
		{ "/hi", 401, "", "" },
		{ "/v1/session/login", 200, "{\"username\":\"bob\",\"password\":\"yeruncle\"}", ""},
		{ "/hi", 200, "", "" },
		{ "/bye", 200, "", "" },
	}
	client := newTestClient(t, testHost, testPort, &messages)

	connection := MakeConnection(testHost, testPort, "bob", "yeruncle", client)
	_, err := connection.Get("/hi")
	assertNoError(t, err)
	_, err = connection.Get("/bye")
	assertNoError(t, err)

	assertMessagesConsumed(t, messages)
}

func TestRestAutoLoginFail(t *testing.T) {
	messages := []Message {
		{ "/hi", 401, "", "" },
		{ "/v1/session/login", 201, "{\"username\":\"bob\",\"password\":\"yeruncle\"}", ""},
	}
	client := newTestClient(t, testHost, testPort, &messages)

	connection := MakeConnection(testHost, testPort, "bob", "yeruncle", client)
	_, err := connection.Get("/hi")
	assertErrorMatchesString(t, err, "Login failed: ")

	assertMessagesConsumed(t, messages)
}

/*  _       _                       _   _
 * (_)_ __ | |_ ___  __ _ _ __ __ _| |_(_) ___  _ __
 * | | '_ \| __/ _ \/ _` | '__/ _` | __| |/ _ \| '_ \
 * | | | | | ||  __/ (_| | | | (_| | |_| | (_) | | | |
 * |_|_| |_|\__\___|\__, |_|  \__,_|\__|_|\___/|_| |_|
 *                  |___/
 *  FIGLET: integration
 */

var (
	host        string
	port        int
	username    string
	password    string
	connection *Connection
	fixturedir  string
	testnum     int
)

func TestMain(m *testing.M) {
	flag.StringVar(&host,     "host",     "",         "Host to connect to")
	flag.IntVar   (&port,     "port",     8000,       "Port to connect to")
	flag.StringVar(&username, "username", "admin",    "Username to connect as")
	flag.StringVar(&password, "password", "Admin123", "Password to use")
	flag.Parse()

	if len(host) != 0 {

		c := MakeConnection(host, port, username, password, new(http.Client))

		_, err := c.CreateDir("/", "gotest")
		if err != nil {
			panic(err)
		}

		fixturedir = "/gotest"

		connection = &c
	}

	code := m.Run()

	if connection != nil && code == 0 {
		err := connection.TreeDeleteCreate(fixturedir)
		if err != nil {
			log.Printf("Failed to clean up test dir %q with tree delete: %v", fixturedir, err)
			code = 1
		}
	}

	os.Exit(code)
}

func setupTest(t *testing.T) (testdir string, cleanup func(t *testing.T)) {
	if connection == nil {
		t.Skip("requires qumulo server")
		return "", nil
	}

	name :+ fmt.Sprintf("testnum-%d", testnum)

	_, err := c.CreateDir(fixturedir, name)
	if err != nil {
		t.Fatal("Error creating subdir %s/%s: %v", fixturedir, name)
	}

	testnum += 1

	testdir = fmt.Sprintf("%s/%s", fixturedir, subdir)

	cleanup = func(t *testing.T) {
		err := connection.TreeDeleteCreate(testdir)
		assertNoError(t, err)
	}

	return
}

func TestRestSmoke(t *testing.T) {
	testdir, cleanup := setupTest(t)
	defer cleanup(t)

	id, err := connection.CreateDir(testdir, "bar")
	assertNoError(t, err)

	t.Logf("Created Dir %v", id)
}

func TestRestCreateDir(t *testing.T) {
	testdir, cleanup := setupTest(t)
	defer cleanup(t)

	id, err := connection.CreateDir(testdir, "bar")
	assertNoError(t, err)

	t.Logf("Created Dir %v", id)
}
